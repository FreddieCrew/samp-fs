#if defined _inc_FS_INCLUDE
	#undef _inc_FS_INCLUDE
#endif
#if defined _FS_INCLUDE_included
	#endinput
#endif
#define _FS_INCLUDE_included

// Include version
public INCLUDE_VERSION = 0x101;

#pragma unused INCLUDE_VERSION

// Copy Modes
static enum CopyModes {
	fs_none,
	fs_skip_existing,
	fs_overwrite_existing,
	fs_update_existing,
	fs_recursive,
	fs_copy_symlinks,
	fs_skip_symlinks,
	fs_directories_only,
	fs_create_symlinks,
	fs_create_hard_links
};

#if defined FS_USE_UTIL
	#define FS_ISNONE (0)
	#define FS_ISDIRECTORY (1)
	#define FS_ISFILE (2)

	#define FS_ERR_NONE (1)
	#define FS_ERR (0)
#endif

// Windows maximum path length
static const MAX_PATH	= 256;


// Directory Natives
native fs_createdir(const dir[]);
native bool: fs_dexists(const dir[]);
native fs_deldir(const dir[]);
native fs_countdirs(const path[]);

// File Natives
native fs_fmove(const path[], const path_to[]);
native fs_fcreate(const path[]);
native fs_fdel(const path[]);
native bool: fs_fexists(const path[]);
native fs_count(const path[]);
native fs_fcopy(const path_from[], const path_to[], {CopyModes, _}:...);

// Utility functions
#if defined FS_USE_UTIL
	stock CheckIfDirectoryOrFileExists(const path[]) {
		if (fs_fexists(path)) 
			return FS_ISFILE;
		else if (fs_dexists(path))
			return FS_ISDIRECTORY
		return FS_ISNONE;
	}

	stock CreateFileAndWrite(const path[], const content[]) {
		new handle;

		if (!fs_fexists(path)) {
			fs_fcreate(path);
			handle = fopen(path);

			if (handle) {
				fwrite(handle, content);
				return FS_ERR_NONE;
			}
			return FS_ERR;
		}

		handle = fopen(path);

		if (handle) {
			fwrite(handle, content);
			return FS_ERR_NONE;
		}
		return FS_ERR;
	}

#endif
